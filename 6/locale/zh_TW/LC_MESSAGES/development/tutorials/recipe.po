# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2025, the Sphinx developers
# This file is distributed under the same license as the Sphinx package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Sphinx 6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-03 20:14+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../development/tutorials/recipe.rst:2
msgid "Developing a \"recipe\" extension"
msgstr ""

#: ../../../development/tutorials/recipe.rst:4
msgid ""
"The objective of this tutorial is to illustrate roles, directives and "
"domains. Once complete, we will be able to use this extension to describe a "
"recipe and reference that recipe from elsewhere in our documentation."
msgstr ""

#: ../../../development/tutorials/recipe.rst:10
msgid ""
"This tutorial is based on a guide first published on `opensource.com`_ and "
"is provided here with the original author's permission."
msgstr ""

#: ../../../development/tutorials/recipe.rst:17
msgid "Overview"
msgstr ""

#: ../../../development/tutorials/recipe.rst:19
msgid "We want the extension to add the following to Sphinx:"
msgstr ""

#: ../../../development/tutorials/recipe.rst:21
msgid ""
"A ``recipe`` :term:`directive`, containing some content describing the "
"recipe steps, along with a ``:contains:`` option highlighting the main "
"ingredients of the recipe."
msgstr ""

#: ../../../development/tutorials/recipe.rst:25
msgid ""
"A ``ref`` :term:`role`, which provides a cross-reference to the recipe "
"itself."
msgstr ""

#: ../../../development/tutorials/recipe.rst:28
msgid ""
"A ``recipe`` :term:`domain`, which allows us to tie together the above role "
"and domain, along with things like indices."
msgstr ""

#: ../../../development/tutorials/recipe.rst:31
msgid "For that, we will need to add the following elements to Sphinx:"
msgstr ""

#: ../../../development/tutorials/recipe.rst:33
msgid "A new directive called ``recipe``"
msgstr ""

#: ../../../development/tutorials/recipe.rst:35
msgid "New indexes to allow us to reference ingredient and recipes"
msgstr ""

#: ../../../development/tutorials/recipe.rst:37
msgid ""
"A new domain called ``recipe``, which will contain the ``recipe`` directive "
"and ``ref`` role"
msgstr ""

#: ../../../development/tutorials/recipe.rst:42
msgid "Prerequisites"
msgstr ""

#: ../../../development/tutorials/recipe.rst:44
msgid ""
"We need the same setup as in :doc:`the previous extensions <todo>`. This "
"time, we will be putting out extension in a file called :file:`recipe.py`."
msgstr ""

#: ../../../development/tutorials/recipe.rst:47
msgid "Here is an example of the folder structure you might obtain:"
msgstr ""

#: ../../../development/tutorials/recipe.rst:49
msgid ""
"└── source\n"
"    ├── _ext\n"
"    │   └── recipe.py\n"
"    ├── conf.py\n"
"    └── index.rst"
msgstr ""
"└── source\n"
"    ├── _ext\n"
"    │   └── recipe.py\n"
"    ├── conf.py\n"
"    └── index.rst"

#: ../../../development/tutorials/recipe.rst:59
msgid "Writing the extension"
msgstr "編寫擴充套件"

#: ../../../development/tutorials/recipe.rst:61
msgid ""
"Open :file:`recipe.py` and paste the following code in it, all of which we "
"will explain in detail shortly:"
msgstr ""

#: ../../../development/tutorials/recipe.rst:64
msgid ""
"from collections import defaultdict\n"
"\n"
"from docutils.parsers.rst import directives\n"
"\n"
"from sphinx import addnodes\n"
"from sphinx.directives import ObjectDescription\n"
"from sphinx.domains import Domain, Index\n"
"from sphinx.roles import XRefRole\n"
"from sphinx.util.nodes import make_refnode\n"
"\n"
"\n"
"class RecipeDirective(ObjectDescription):\n"
"    \"\"\"A custom directive that describes a recipe.\"\"\"\n"
"\n"
"    has_content = True\n"
"    required_arguments = 1\n"
"    option_spec = {\n"
"        'contains': directives.unchanged_required,\n"
"    }\n"
"\n"
"    def handle_signature(self, sig, signode):\n"
"        signode += addnodes.desc_name(text=sig)\n"
"        return sig\n"
"\n"
"    def add_target_and_index(self, name_cls, sig, signode):\n"
"        signode['ids'].append('recipe' + '-' + sig)\n"
"        if 'contains' in self.options:\n"
"            ingredients = [\n"
"                x.strip() for x in self.options.get('contains').split(',')]\n"
"\n"
"            recipes = self.env.get_domain('recipe')\n"
"            recipes.add_recipe(sig, ingredients)\n"
"\n"
"\n"
"class IngredientIndex(Index):\n"
"    \"\"\"A custom index that creates an ingredient matrix.\"\"\"\n"
"\n"
"    name = 'ingredient'\n"
"    localname = 'Ingredient Index'\n"
"    shortname = 'Ingredient'\n"
"\n"
"    def generate(self, docnames=None):\n"
"        content = defaultdict(list)\n"
"\n"
"        recipes = {name: (dispname, typ, docname, anchor)\n"
"                   for name, dispname, typ, docname, anchor, _\n"
"                   in self.domain.get_objects()}\n"
"        recipe_ingredients = self.domain.data['recipe_ingredients']\n"
"        ingredient_recipes = defaultdict(list)\n"
"\n"
"        # flip from recipe_ingredients to ingredient_recipes\n"
"        for recipe_name, ingredients in recipe_ingredients.items():\n"
"            for ingredient in ingredients:\n"
"                ingredient_recipes[ingredient].append(recipe_name)\n"
"\n"
"        # convert the mapping of ingredient to recipes to produce the "
"expected\n"
"        # output, shown below, using the ingredient name as a key to group\n"
"        #\n"
"        # name, subtype, docname, anchor, extra, qualifier, description\n"
"        for ingredient, recipe_names in ingredient_recipes.items():\n"
"            for recipe_name in recipe_names:\n"
"                dispname, typ, docname, anchor = recipes[recipe_name]\n"
"                content[ingredient].append(\n"
"                    (dispname, 0, docname, anchor, docname, '', typ))\n"
"\n"
"        # convert the dict to the sorted list of tuples expected\n"
"        content = sorted(content.items())\n"
"\n"
"        return content, True\n"
"\n"
"\n"
"class RecipeIndex(Index):\n"
"    \"\"\"A custom index that creates an recipe matrix.\"\"\"\n"
"\n"
"    name = 'recipe'\n"
"    localname = 'Recipe Index'\n"
"    shortname = 'Recipe'\n"
"\n"
"    def generate(self, docnames=None):\n"
"        content = defaultdict(list)\n"
"\n"
"        # sort the list of recipes in alphabetical order\n"
"        recipes = self.domain.get_objects()\n"
"        recipes = sorted(recipes, key=lambda recipe: recipe[0])\n"
"\n"
"        # generate the expected output, shown below, from the above using "
"the\n"
"        # first letter of the recipe as a key to group thing\n"
"        #\n"
"        # name, subtype, docname, anchor, extra, qualifier, description\n"
"        for _name, dispname, typ, docname, anchor, _priority in recipes:\n"
"            content[dispname[0].lower()].append(\n"
"                (dispname, 0, docname, anchor, docname, '', typ))\n"
"\n"
"        # convert the dict to the sorted list of tuples expected\n"
"        content = sorted(content.items())\n"
"\n"
"        return content, True\n"
"\n"
"\n"
"class RecipeDomain(Domain):\n"
"\n"
"    name = 'recipe'\n"
"    label = 'Recipe Sample'\n"
"    roles = {\n"
"        'ref': XRefRole(),\n"
"    }\n"
"    directives = {\n"
"        'recipe': RecipeDirective,\n"
"    }\n"
"    indices = {\n"
"        RecipeIndex,\n"
"        IngredientIndex,\n"
"    }\n"
"    initial_data = {\n"
"        'recipes': [],  # object list\n"
"        'recipe_ingredients': {},  # name -> object\n"
"    }\n"
"\n"
"    def get_full_qualified_name(self, node):\n"
"        return f'recipe.{node.arguments[0]}'\n"
"\n"
"    def get_objects(self):\n"
"        yield from self.data['recipes']\n"
"\n"
"    def resolve_xref(self, env, fromdocname, builder, typ, target, node,\n"
"                     contnode):\n"
"        match = [(docname, anchor)\n"
"                 for name, sig, typ, docname, anchor, prio\n"
"                 in self.get_objects() if sig == target]\n"
"\n"
"        if len(match) > 0:\n"
"            todocname = match[0][0]\n"
"            targ = match[0][1]\n"
"\n"
"            return make_refnode(builder, fromdocname, todocname, targ,\n"
"                                contnode, targ)\n"
"        else:\n"
"            print('Awww, found nothing')\n"
"            return None\n"
"\n"
"    def add_recipe(self, signature, ingredients):\n"
"        \"\"\"Add a new recipe to the domain.\"\"\"\n"
"        name = f'recipe.{signature}'\n"
"        anchor = f'recipe-{signature}'\n"
"\n"
"        self.data['recipe_ingredients'][name] = ingredients\n"
"        # name, dispname, type, docname, anchor, priority\n"
"        self.data['recipes'].append(\n"
"            (name, signature, 'Recipe', self.env.docname, anchor, 0))\n"
"\n"
"\n"
"def setup(app):\n"
"    app.add_domain(RecipeDomain)\n"
"\n"
"    return {\n"
"        'version': '0.1',\n"
"        'parallel_read_safe': True,\n"
"        'parallel_write_safe': True,\n"
"    }\n"
msgstr ""

#: ../../../development/tutorials/recipe.rst:68
msgid ""
"Let's look at each piece of this extension step-by-step to explain what's "
"going on."
msgstr ""

#: ../../../development/tutorials/recipe.rst:72
msgid "The directive class"
msgstr "指示詞類別"

#: ../../../development/tutorials/recipe.rst:73
msgid "The first thing to examine is the ``RecipeDirective`` directive:"
msgstr ""

#: ../../../development/tutorials/recipe.rst:75
msgid ""
"class RecipeDirective(ObjectDescription):\n"
"    \"\"\"A custom directive that describes a recipe.\"\"\"\n"
"\n"
"    has_content = True\n"
"    required_arguments = 1\n"
"    option_spec = {\n"
"        'contains': directives.unchanged_required,\n"
"    }\n"
"\n"
"    def handle_signature(self, sig, signode):\n"
"        signode += addnodes.desc_name(text=sig)\n"
"        return sig\n"
"\n"
"    def add_target_and_index(self, name_cls, sig, signode):\n"
"        signode['ids'].append('recipe' + '-' + sig)\n"
"        if 'contains' in self.options:\n"
"            ingredients = [\n"
"                x.strip() for x in self.options.get('contains').split(',')]\n"
"\n"
"            recipes = self.env.get_domain('recipe')\n"
"            recipes.add_recipe(sig, ingredients)\n"
msgstr ""

#: ../../../development/tutorials/recipe.rst:80
msgid ""
"Unlike :doc:`helloworld` and :doc:`todo`, this directive doesn't derive "
"from :class:`docutils.parsers.rst.Directive` and doesn't define a ``run`` "
"method. Instead, it derives from :class:`sphinx.directives."
"ObjectDescription` and defines  ``handle_signature`` and "
"``add_target_and_index`` methods. This is because ``ObjectDescription`` is a "
"special-purpose directive that's intended for describing things like "
"classes, functions, or, in our case, recipes. More specifically, "
"``handle_signature`` implements parsing the signature of the directive and "
"passes on the object's name and type to its superclass, while "
"``add_target_and_index`` adds a target (to link to) and an entry to the "
"index for this node."
msgstr ""

#: ../../../development/tutorials/recipe.rst:91
msgid ""
"We also see that this directive defines ``has_content``, "
"``required_arguments`` and ``option_spec``. Unlike the ``TodoDirective`` "
"directive added in the :doc:`previous tutorial <todo>`, this directive takes "
"a single argument, the recipe name, and an option, ``contains``, in addition "
"to the nested reStructuredText in the body."
msgstr ""

#: ../../../development/tutorials/recipe.rst:98
msgid "The index classes"
msgstr "索引類別"

#: ../../../development/tutorials/recipe.rst:101
msgid "Todo"
msgstr ""

#: ../../../development/tutorials/recipe.rst:101
msgid "Add brief overview of indices"
msgstr ""

#: ../../../development/tutorials/recipe.rst:103
msgid ""
"class IngredientIndex(Index):\n"
"    \"\"\"A custom index that creates an ingredient matrix.\"\"\"\n"
"\n"
"    name = 'ingredient'\n"
"    localname = 'Ingredient Index'\n"
"    shortname = 'Ingredient'\n"
"\n"
"    def generate(self, docnames=None):\n"
"        content = defaultdict(list)\n"
"\n"
"        recipes = {name: (dispname, typ, docname, anchor)\n"
"                   for name, dispname, typ, docname, anchor, _\n"
"                   in self.domain.get_objects()}\n"
"        recipe_ingredients = self.domain.data['recipe_ingredients']\n"
"        ingredient_recipes = defaultdict(list)\n"
"\n"
"        # flip from recipe_ingredients to ingredient_recipes\n"
"        for recipe_name, ingredients in recipe_ingredients.items():\n"
"            for ingredient in ingredients:\n"
"                ingredient_recipes[ingredient].append(recipe_name)\n"
"\n"
"        # convert the mapping of ingredient to recipes to produce the "
"expected\n"
"        # output, shown below, using the ingredient name as a key to group\n"
"        #\n"
"        # name, subtype, docname, anchor, extra, qualifier, description\n"
"        for ingredient, recipe_names in ingredient_recipes.items():\n"
"            for recipe_name in recipe_names:\n"
"                dispname, typ, docname, anchor = recipes[recipe_name]\n"
"                content[ingredient].append(\n"
"                    (dispname, 0, docname, anchor, docname, '', typ))\n"
"\n"
"        # convert the dict to the sorted list of tuples expected\n"
"        content = sorted(content.items())\n"
"\n"
"        return content, True\n"
msgstr ""

#: ../../../development/tutorials/recipe.rst:108
msgid ""
"class RecipeIndex(Index):\n"
"    \"\"\"A custom index that creates an recipe matrix.\"\"\"\n"
"\n"
"    name = 'recipe'\n"
"    localname = 'Recipe Index'\n"
"    shortname = 'Recipe'\n"
"\n"
"    def generate(self, docnames=None):\n"
"        content = defaultdict(list)\n"
"\n"
"        # sort the list of recipes in alphabetical order\n"
"        recipes = self.domain.get_objects()\n"
"        recipes = sorted(recipes, key=lambda recipe: recipe[0])\n"
"\n"
"        # generate the expected output, shown below, from the above using "
"the\n"
"        # first letter of the recipe as a key to group thing\n"
"        #\n"
"        # name, subtype, docname, anchor, extra, qualifier, description\n"
"        for _name, dispname, typ, docname, anchor, _priority in recipes:\n"
"            content[dispname[0].lower()].append(\n"
"                (dispname, 0, docname, anchor, docname, '', typ))\n"
"\n"
"        # convert the dict to the sorted list of tuples expected\n"
"        content = sorted(content.items())\n"
"\n"
"        return content, True\n"
msgstr ""

#: ../../../development/tutorials/recipe.rst:113
msgid ""
"Both ``IngredientIndex`` and ``RecipeIndex`` are derived from :class:"
"`Index`. They implement custom logic to generate a tuple of values that "
"define the index. Note that ``RecipeIndex`` is a simple index that has only "
"one entry. Extending it to cover more object types is not yet part of the "
"code."
msgstr ""

#: ../../../development/tutorials/recipe.rst:118
msgid ""
"Both indices use the method :meth:`Index.generate` to do their work. This "
"method combines the information from our domain, sorts it, and returns it in "
"a list structure that will be accepted by Sphinx. This might look "
"complicated but all it really is is a list of tuples like ``('tomato', "
"'TomatoSoup', 'test', 'rec-TomatoSoup',...)``. Refer to the :doc:`domain API "
"guide </extdev/domainapi>` for more information on this API."
msgstr ""

#: ../../../development/tutorials/recipe.rst:125
msgid ""
"These index pages can be referenced with the :rst:role:`ref` role by "
"combining the domain name and the index ``name`` value. For example, "
"``RecipeIndex`` can be referenced with ``:ref:`recipe-recipe``` and "
"``IngredientIndex`` can be referenced with ``:ref:`recipe-ingredient```."
msgstr ""

#: ../../../development/tutorials/recipe.rst:131
msgid "The domain"
msgstr "領域"

#: ../../../development/tutorials/recipe.rst:132
msgid ""
"A Sphinx domain is a specialized container that ties together roles, "
"directives, and indices, among other things. Let's look at the domain we're "
"creating here."
msgstr ""

#: ../../../development/tutorials/recipe.rst:136
msgid ""
"class RecipeDomain(Domain):\n"
"\n"
"    name = 'recipe'\n"
"    label = 'Recipe Sample'\n"
"    roles = {\n"
"        'ref': XRefRole(),\n"
"    }\n"
"    directives = {\n"
"        'recipe': RecipeDirective,\n"
"    }\n"
"    indices = {\n"
"        RecipeIndex,\n"
"        IngredientIndex,\n"
"    }\n"
"    initial_data = {\n"
"        'recipes': [],  # object list\n"
"        'recipe_ingredients': {},  # name -> object\n"
"    }\n"
"\n"
"    def get_full_qualified_name(self, node):\n"
"        return f'recipe.{node.arguments[0]}'\n"
"\n"
"    def get_objects(self):\n"
"        yield from self.data['recipes']\n"
"\n"
"    def resolve_xref(self, env, fromdocname, builder, typ, target, node,\n"
"                     contnode):\n"
"        match = [(docname, anchor)\n"
"                 for name, sig, typ, docname, anchor, prio\n"
"                 in self.get_objects() if sig == target]\n"
"\n"
"        if len(match) > 0:\n"
"            todocname = match[0][0]\n"
"            targ = match[0][1]\n"
"\n"
"            return make_refnode(builder, fromdocname, todocname, targ,\n"
"                                contnode, targ)\n"
"        else:\n"
"            print('Awww, found nothing')\n"
"            return None\n"
"\n"
"    def add_recipe(self, signature, ingredients):\n"
"        \"\"\"Add a new recipe to the domain.\"\"\"\n"
"        name = f'recipe.{signature}'\n"
"        anchor = f'recipe-{signature}'\n"
"\n"
"        self.data['recipe_ingredients'][name] = ingredients\n"
"        # name, dispname, type, docname, anchor, priority\n"
"        self.data['recipes'].append(\n"
"            (name, signature, 'Recipe', self.env.docname, anchor, 0))\n"
msgstr ""

#: ../../../development/tutorials/recipe.rst:141
msgid ""
"There are some interesting things to note about this ``recipe`` domain and "
"domains in general. Firstly, we actually register our directives, roles and "
"indices here, via the ``directives``, ``roles`` and ``indices`` attributes, "
"rather than via calls later on in ``setup``. We can also note that we aren't "
"actually defining a custom role and are instead reusing the :class:`sphinx."
"roles.XRefRole` role and defining the :class:`sphinx.domains.Domain."
"resolve_xref` method. This method takes two arguments, ``typ`` and "
"``target``, which refer to the cross-reference type and its target name. "
"We'll use ``target`` to resolve our destination from our domain's "
"``recipes`` because we currently have only one type of node."
msgstr ""

#: ../../../development/tutorials/recipe.rst:152
msgid ""
"Moving on, we can see that we've defined ``initial_data``. The values "
"defined in ``initial_data`` will be copied to ``env."
"domaindata[domain_name]`` as the initial data of the domain, and domain "
"instances can access it via ``self.data``. We see that we have defined two "
"items in ``initial_data``: ``recipes`` and ``recipe_ingredients``. Each "
"contains a list of all objects defined (i.e. all recipes) and a hash that "
"maps a canonical ingredient name to the list of objects. The way we name "
"objects is common across our extension and is defined in the "
"``get_full_qualified_name`` method. For each object created, the canonical "
"name is ``recipe.<recipename>``, where ``<recipename>`` is the name the "
"documentation writer gives the object (a recipe). This enables the extension "
"to use different object types that share the same name. Having a canonical "
"name and central place for our objects is a huge advantage. Both our indices "
"and our cross-referencing code use this feature."
msgstr ""

#: ../../../development/tutorials/recipe.rst:167
msgid "The ``setup`` function"
msgstr "``setup`` 函式"

#: ../../../development/tutorials/recipe.rst:170
msgid ""
":doc:`As always <todo>`, the ``setup`` function is a requirement and is used "
"to hook the various parts of our extension into Sphinx. Let's look at the "
"``setup`` function for this extension."
msgstr ""

#: ../../../development/tutorials/recipe.rst:174
msgid ""
"def setup(app):\n"
"    app.add_domain(RecipeDomain)\n"
"\n"
"    return {\n"
"        'version': '0.1',\n"
"        'parallel_read_safe': True,\n"
"        'parallel_write_safe': True,\n"
"    }\n"
msgstr ""

#: ../../../development/tutorials/recipe.rst:179
msgid ""
"This looks a little different to what we're used to seeing. There are no "
"calls to :meth:`~Sphinx.add_directive` or even :meth:`~Sphinx.add_role`. "
"Instead, we have a single call to :meth:`~Sphinx.add_domain` followed by "
"some initialization of the :ref:`standard domain <domains-std>`. This is "
"because we had already registered our directives, roles and indexes as part "
"of the directive itself."
msgstr ""

#: ../../../development/tutorials/recipe.rst:188
msgid "Using the extension"
msgstr "使用擴充套件"

#: ../../../development/tutorials/recipe.rst:190
msgid "You can now use the extension throughout your project. For example:"
msgstr ""

#: ../../../development/tutorials/recipe.rst:192
msgid "index.rst"
msgstr ""

#: ../../../development/tutorials/recipe.rst:192
msgid ""
"Joe's Recipes\n"
"=============\n"
"\n"
"Below are a collection of my favourite recipes. I highly recommend the\n"
":recipe:ref:`TomatoSoup` recipe in particular!\n"
"\n"
".. toctree::\n"
"\n"
"   tomato-soup"
msgstr ""

#: ../../../development/tutorials/recipe.rst:205
msgid "tomato-soup.rst"
msgstr ""

#: ../../../development/tutorials/recipe.rst:205
msgid ""
"The recipe contains `tomato` and `cilantro`.\n"
"\n"
".. recipe:recipe:: TomatoSoup\n"
"   :contains: tomato, cilantro, salt, pepper\n"
"\n"
"   This recipe is a tasty tomato soup, combine all ingredients\n"
"   and cook."
msgstr ""

#: ../../../development/tutorials/recipe.rst:216
msgid ""
"The important things to note are the use of the ``:recipe:ref:`` role to "
"cross-reference the recipe actually defined elsewhere (using the ``:recipe:"
"recipe:`` directive)."
msgstr ""

#: ../../../development/tutorials/recipe.rst:222
msgid "Further reading"
msgstr "延伸閱讀"

#: ../../../development/tutorials/recipe.rst:224
msgid ""
"For more information, refer to the `docutils`_ documentation and :doc:`/"
"extdev/index`."
msgstr ""
