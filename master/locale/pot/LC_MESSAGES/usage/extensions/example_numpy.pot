# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2007-2025, the Sphinx developers
# This file is distributed under the same license as the Sphinx package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Sphinx master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-03 20:13+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../usage/extensions/example_numpy.rst:6
msgid "Example NumPy Style Python Docstrings"
msgstr ""

#: ../../../usage/extensions/example_numpy.rst:10
msgid ":ref:`example_google`"
msgstr ""

#: ../../../usage/extensions/example_numpy.rst:14
msgid "Download: :download:`example_numpy.py <example_numpy.py>`"
msgstr ""

#: ../../../usage/extensions/example_numpy.rst:16
msgid ""
"\"\"\"Example NumPy style docstrings.\n"
"\n"
"This module demonstrates documentation as specified by the `NumPy\n"
"Documentation HOWTO`_. Docstrings may extend over multiple lines. Sections\n"
"are created with a section header followed by an underline of equal length.\n"
"\n"
"Example\n"
"-------\n"
"Examples can be given using either the ``Example`` or ``Examples``\n"
"sections. Sections support any reStructuredText formatting, including\n"
"literal blocks::\n"
"\n"
"    $ python example_numpy.py\n"
"\n"
"\n"
"Section breaks are created with two blank lines. Section breaks are also\n"
"implicitly created anytime a new section starts. Section bodies *may* be\n"
"indented:\n"
"\n"
"Notes\n"
"-----\n"
"    This is an example of an indented section. It's like any other section,\n"
"    but the body is indented to help it stand out from surrounding text.\n"
"\n"
"If a section is indented, then a section break is created by\n"
"resuming unindented text.\n"
"\n"
"Attributes\n"
"----------\n"
"module_level_variable1 : int\n"
"    Module level variables may be documented in either the ``Attributes``\n"
"    section of the module docstring, or in an inline docstring immediately\n"
"    following the variable.\n"
"\n"
"    Either form is acceptable, but the two should not be mixed. Choose\n"
"    one convention to document module level variables and be consistent\n"
"    with it.\n"
"\n"
"\n"
".. _NumPy docstring standard:\n"
"   https://numpydoc.readthedocs.io/en/latest/format.html#docstring-standard\n"
"\n"
"\"\"\"\n"
"\n"
"module_level_variable1 = 12345\n"
"\n"
"module_level_variable2 = 98765\n"
"\"\"\"int: Module level variable documented inline.\n"
"\n"
"The docstring may span multiple lines. The type may optionally be specified\n"
"on the first line, separated by a colon.\n"
"\"\"\"\n"
"\n"
"\n"
"def function_with_types_in_docstring(param1, param2):\n"
"    \"\"\"Example function with types documented in the docstring.\n"
"\n"
"    :pep:`484` type annotations are supported. If attribute, parameter, and\n"
"    return types are annotated according to `PEP 484`_, they do not need to "
"be\n"
"    included in the docstring:\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    param1 : int\n"
"        The first parameter.\n"
"    param2 : str\n"
"        The second parameter.\n"
"\n"
"    Returns\n"
"    -------\n"
"    bool\n"
"        True if successful, False otherwise.\n"
"    \"\"\"\n"
"\n"
"\n"
"def function_with_pep484_type_annotations(param1: int, param2: str) -> "
"bool:\n"
"    \"\"\"Example function with PEP 484 type annotations.\n"
"\n"
"    The return type must be duplicated in the docstring to comply\n"
"    with the NumPy docstring style.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    param1\n"
"        The first parameter.\n"
"    param2\n"
"        The second parameter.\n"
"\n"
"    Returns\n"
"    -------\n"
"    bool\n"
"        True if successful, False otherwise.\n"
"\n"
"    \"\"\"\n"
"\n"
"\n"
"def module_level_function(param1, param2=None, *args, **kwargs):\n"
"    \"\"\"This is an example of a module level function.\n"
"\n"
"    Function parameters should be documented in the ``Parameters`` section.\n"
"    The name of each parameter is required. The type and description of "
"each\n"
"    parameter is optional, but should be included if not obvious.\n"
"\n"
"    If ``*args`` or ``**kwargs`` are accepted,\n"
"    they should be listed as ``*args`` and ``**kwargs``.\n"
"\n"
"    The format for a parameter is::\n"
"\n"
"        name : type\n"
"            description\n"
"\n"
"            The description may span multiple lines. Following lines\n"
"            should be indented to match the first line of the description.\n"
"            The \": type\" is optional.\n"
"\n"
"            Multiple paragraphs are supported in parameter\n"
"            descriptions.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    param1 : int\n"
"        The first parameter.\n"
"    param2 : :obj:`str`, optional\n"
"        The second parameter.\n"
"    *args\n"
"        Variable length argument list.\n"
"    **kwargs\n"
"        Arbitrary keyword arguments.\n"
"\n"
"    Returns\n"
"    -------\n"
"    bool\n"
"        True if successful, False otherwise.\n"
"\n"
"        The return type is not optional. The ``Returns`` section may span\n"
"        multiple lines and paragraphs. Following lines should be indented "
"to\n"
"        match the first line of the description.\n"
"\n"
"        The ``Returns`` section supports any reStructuredText formatting,\n"
"        including literal blocks::\n"
"\n"
"            {\n"
"                'param1': param1,\n"
"                'param2': param2,\n"
"            }\n"
"\n"
"    Raises\n"
"    ------\n"
"    AttributeError\n"
"        The ``Raises`` section is a list of all exceptions\n"
"        that are relevant to the interface.\n"
"    ValueError\n"
"        If `param2` is equal to `param1`.\n"
"\n"
"    \"\"\"\n"
"    if param1 == param2:\n"
"        msg = 'param1 may not be equal to param2'\n"
"        raise ValueError(msg)\n"
"    return True\n"
"\n"
"\n"
"def example_generator(n):\n"
"    \"\"\"Generators have a ``Yields`` section instead of a ``Returns`` "
"section.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    n : int\n"
"        The upper limit of the range to generate, from 0 to `n` - 1.\n"
"\n"
"    Yields\n"
"    ------\n"
"    int\n"
"        The next number in the range of 0 to `n` - 1.\n"
"\n"
"    Examples\n"
"    --------\n"
"    Examples should be written in doctest format, and should illustrate how\n"
"    to use the function.\n"
"\n"
"    >>> print([i for i in example_generator(4)])\n"
"    [0, 1, 2, 3]\n"
"\n"
"    \"\"\"\n"
"    yield from range(n)\n"
"\n"
"\n"
"class ExampleError(Exception):\n"
"    \"\"\"Exceptions are documented in the same way as classes.\n"
"\n"
"    The __init__ method may be documented in either the class level\n"
"    docstring, or as a docstring on the __init__ method itself.\n"
"\n"
"    Either form is acceptable, but the two should not be mixed. Choose one\n"
"    convention to document the __init__ method and be consistent with it.\n"
"\n"
"    Note\n"
"    ----\n"
"    Do not include the `self` parameter in the ``Parameters`` section.\n"
"\n"
"    Parameters\n"
"    ----------\n"
"    msg : str\n"
"        Human readable string describing the exception.\n"
"    code : :obj:`int`, optional\n"
"        Numeric error code.\n"
"\n"
"    Attributes\n"
"    ----------\n"
"    msg : str\n"
"        Human readable string describing the exception.\n"
"    code : int\n"
"        Numeric error code.\n"
"\n"
"    \"\"\"\n"
"\n"
"    def __init__(self, msg, code):\n"
"        self.msg = msg\n"
"        self.code = code\n"
"\n"
"\n"
"class ExampleClass:\n"
"    \"\"\"The summary line for a class docstring should fit on one line.\n"
"\n"
"    If the class has public attributes, they may be documented here\n"
"    in an ``Attributes`` section and follow the same formatting as a\n"
"    function's ``Args`` section. Alternatively, attributes may be "
"documented\n"
"    inline with the attribute's declaration (see __init__ method below).\n"
"\n"
"    Properties created with the ``@property`` decorator should be "
"documented\n"
"    in the property's getter method.\n"
"\n"
"    Attributes\n"
"    ----------\n"
"    attr1 : str\n"
"        Description of `attr1`.\n"
"    attr2 : :obj:`int`, optional\n"
"        Description of `attr2`.\n"
"\n"
"    \"\"\"\n"
"\n"
"    def __init__(self, param1, param2, param3):\n"
"        \"\"\"Example of docstring on the __init__ method.\n"
"\n"
"        The __init__ method may be documented in either the class level\n"
"        docstring, or as a docstring on the __init__ method itself.\n"
"\n"
"        Either form is acceptable, but the two should not be mixed. Choose "
"one\n"
"        convention to document the __init__ method and be consistent with "
"it.\n"
"\n"
"        Note\n"
"        ----\n"
"        Do not include the `self` parameter in the ``Parameters`` section.\n"
"\n"
"        Parameters\n"
"        ----------\n"
"        param1 : str\n"
"            Description of `param1`.\n"
"        param2 : list(str)\n"
"            Description of `param2`. Multiple\n"
"            lines are supported.\n"
"        param3 : :obj:`int`, optional\n"
"            Description of `param3`.\n"
"\n"
"        \"\"\"\n"
"        self.attr1 = param1\n"
"        self.attr2 = param2\n"
"        self.attr3 = param3  #: Doc comment *inline* with attribute\n"
"\n"
"        #: list(str): Doc comment *before* attribute, with type specified\n"
"        self.attr4 = ['attr4']\n"
"\n"
"        self.attr5 = None\n"
"        \"\"\"str: Docstring *after* attribute, with type specified.\"\"\"\n"
"\n"
"    @property\n"
"    def readonly_property(self):\n"
"        \"\"\"str: Properties should be documented in their getter method."
"\"\"\"\n"
"        return 'readonly_property'\n"
"\n"
"    @property\n"
"    def readwrite_property(self):\n"
"        \"\"\"list(str): Properties with both a getter and setter\n"
"        should only be documented in their getter method.\n"
"\n"
"        If the setter method contains notable behavior, it should be\n"
"        mentioned here.\n"
"        \"\"\"\n"
"        return ['readwrite_property']\n"
"\n"
"    @readwrite_property.setter\n"
"    def readwrite_property(self, value):\n"
"        _ = value\n"
"\n"
"    def example_method(self, param1, param2):\n"
"        \"\"\"Class methods are similar to regular functions.\n"
"\n"
"        Note\n"
"        ----\n"
"        Do not include the `self` parameter in the ``Parameters`` section.\n"
"\n"
"        Parameters\n"
"        ----------\n"
"        param1\n"
"            The first parameter.\n"
"        param2\n"
"            The second parameter.\n"
"\n"
"        Returns\n"
"        -------\n"
"        bool\n"
"            True if successful, False otherwise.\n"
"\n"
"        \"\"\"\n"
"        return True\n"
"\n"
"    def __special__(self):\n"
"        \"\"\"By default special members with docstrings are not included.\n"
"\n"
"        Special members are any methods or attributes that start with and\n"
"        end with a double underscore. Any special member with a docstring\n"
"        will be included in the output, if\n"
"        ``napoleon_include_special_with_doc`` is set to True.\n"
"\n"
"        This behavior can be enabled by changing the following setting in\n"
"        Sphinx's conf.py::\n"
"\n"
"            napoleon_include_special_with_doc = True\n"
"\n"
"        \"\"\"\n"
"        pass\n"
"\n"
"    def __special_without_docstring__(self):\n"
"        pass\n"
"\n"
"    def _private(self):\n"
"        \"\"\"By default private members are not included.\n"
"\n"
"        Private members are any methods or attributes that start with an\n"
"        underscore and are *not* special. By default they are not included\n"
"        in the output.\n"
"\n"
"        This behavior can be changed such that private members *are* "
"included\n"
"        by changing the following setting in Sphinx's conf.py::\n"
"\n"
"            napoleon_include_private_with_doc = True\n"
"\n"
"        \"\"\"\n"
"        pass\n"
"\n"
"    def _private_without_docstring(self):\n"
"        pass\n"
msgstr ""
